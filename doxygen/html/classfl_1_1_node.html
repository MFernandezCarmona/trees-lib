<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Trees: fl::Node Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Trees
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classfl_1_1_node.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classfl_1_1_node-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">fl::Node Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Abstract <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>, single element of a component tree.  
 <a href="classfl_1_1_node.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="node_8h_source.html">node.h</a>&gt;</code></p>

<p>Inherited by <a class="el" href="classfl_1_1_inclusion_node.html">fl::InclusionNode</a>, and <a class="el" href="classfl_1_1_partitioning_node.html">fl::PartitioningNode</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2c866c99680f0f89fb3619169530a023"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#a2c866c99680f0f89fb3619169530a023">Node</a> (const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;S)</td></tr>
<tr class="memdesc:a2c866c99680f0f89fb3619169530a023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor assigning pixels to the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>.  <a href="#a2c866c99680f0f89fb3619169530a023">More...</a><br /></td></tr>
<tr class="separator:a2c866c99680f0f89fb3619169530a023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a364d627759d8a35aebfd196a12a09943"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#a364d627759d8a35aebfd196a12a09943">Node</a> (const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;S, const std::vector&lt; <a class="el" href="classfl_1_1_node.html">Node</a> * &gt; &amp;children)</td></tr>
<tr class="memdesc:a364d627759d8a35aebfd196a12a09943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor assigning both pixels and all children to the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>.  <a href="#a364d627759d8a35aebfd196a12a09943">More...</a><br /></td></tr>
<tr class="separator:a364d627759d8a35aebfd196a12a09943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c311cbdd46be03842ab4c5f287b305c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c311cbdd46be03842ab4c5f287b305c"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#a2c311cbdd46be03842ab4c5f287b305c">~Node</a> ()</td></tr>
<tr class="memdesc:a2c311cbdd46be03842ab4c5f287b305c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class destructor. <br /></td></tr>
<tr class="separator:a2c311cbdd46be03842ab4c5f287b305c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327cb611fb189d5252b6026917c226b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a327cb611fb189d5252b6026917c226b7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#a327cb611fb189d5252b6026917c226b7">Node</a> (const <a class="el" href="classfl_1_1_node.html">Node</a> &amp;other)</td></tr>
<tr class="memdesc:a327cb611fb189d5252b6026917c226b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br /></td></tr>
<tr class="separator:a327cb611fb189d5252b6026917c226b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad55b74418c40b3c1eeb9dfa372579e4f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classfl_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#ad55b74418c40b3c1eeb9dfa372579e4f">parent</a> (int depth=1) const </td></tr>
<tr class="memdesc:ad55b74418c40b3c1eeb9dfa372579e4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a parent or ancestral <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>.  <a href="#ad55b74418c40b3c1eeb9dfa372579e4f">More...</a><br /></td></tr>
<tr class="separator:ad55b74418c40b3c1eeb9dfa372579e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a3448e33ea25261c66c7c23185dee5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfl_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#a64a3448e33ea25261c66c7c23185dee5">parentBySize</a> (double perc, int oriSize=0, int jumps=0)</td></tr>
<tr class="memdesc:a64a3448e33ea25261c66c7c23185dee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a parent or ancestral <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> determined by it's size.  <a href="#a64a3448e33ea25261c66c7c23185dee5">More...</a><br /></td></tr>
<tr class="separator:a64a3448e33ea25261c66c7c23185dee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6fced27be60dc410a9f3ab7b0b2ae21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#ad6fced27be60dc410a9f3ab7b0b2ae21">parentBySize</a> (double perc, std::vector&lt; <a class="el" href="classfl_1_1_node.html">Node</a> * &gt; &amp;pathBetween, int oriSize=0, int jumps=0)</td></tr>
<tr class="memdesc:ad6fced27be60dc410a9f3ab7b0b2ae21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of ancestral <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>s of a <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>, up to the ancestral <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> larger than a size limit.  <a href="#ad6fced27be60dc410a9f3ab7b0b2ae21">More...</a><br /></td></tr>
<tr class="separator:ad6fced27be60dc410a9f3ab7b0b2ae21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e3b3ac0f3ab959cb15c351bd6f14b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#af5e3b3ac0f3ab959cb15c351bd6f14b9">isRoot</a> () const </td></tr>
<tr class="memdesc:af5e3b3ac0f3ab959cb15c351bd6f14b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> is a root <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>.  <a href="#af5e3b3ac0f3ab959cb15c351bd6f14b9">More...</a><br /></td></tr>
<tr class="separator:af5e3b3ac0f3ab959cb15c351bd6f14b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a858d389047b889525fb20adcf0fe62b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#a858d389047b889525fb20adcf0fe62b7">addChild</a> (<a class="el" href="classfl_1_1_node.html">Node</a> *ch)</td></tr>
<tr class="memdesc:a858d389047b889525fb20adcf0fe62b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a child <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>.  <a href="#a858d389047b889525fb20adcf0fe62b7">More...</a><br /></td></tr>
<tr class="separator:a858d389047b889525fb20adcf0fe62b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5270dac7d9e9ea39b09fd7b38d7851a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#a5270dac7d9e9ea39b09fd7b38d7851a0">addElement</a> (const std::pair&lt; int, int &gt; &amp;px)</td></tr>
<tr class="memdesc:a5270dac7d9e9ea39b09fd7b38d7851a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a single element to this <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>.  <a href="#a5270dac7d9e9ea39b09fd7b38d7851a0">More...</a><br /></td></tr>
<tr class="separator:a5270dac7d9e9ea39b09fd7b38d7851a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c16de5d62ba24897226bfe957d327a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#a3c16de5d62ba24897226bfe957d327a1">getElements</a> (std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;px) const </td></tr>
<tr class="memdesc:a3c16de5d62ba24897226bfe957d327a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the pixels of the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>.  <a href="#a3c16de5d62ba24897226bfe957d327a1">More...</a><br /></td></tr>
<tr class="separator:a3c16de5d62ba24897226bfe957d327a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fca7edd7d958f8e5177f2e8fdddc157"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::pair<br class="typebreak" />
&lt; int, int &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#a6fca7edd7d958f8e5177f2e8fdddc157">getOwnElements</a> () const </td></tr>
<tr class="memdesc:a6fca7edd7d958f8e5177f2e8fdddc157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all self-pixels of the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>.  <a href="#a6fca7edd7d958f8e5177f2e8fdddc157">More...</a><br /></td></tr>
<tr class="separator:a6fca7edd7d958f8e5177f2e8fdddc157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af243b1b9a8db11129fd7603f1cb00bbc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#af243b1b9a8db11129fd7603f1cb00bbc">assignLevel</a> (const double &amp;<a class="el" href="classfl_1_1_node.html#a035a1760c40a956ae12cbaf5d1bb2d0a">level</a>)</td></tr>
<tr class="memdesc:af243b1b9a8db11129fd7603f1cb00bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a <code>level</code> to the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>.  <a href="#af243b1b9a8db11129fd7603f1cb00bbc">More...</a><br /></td></tr>
<tr class="separator:af243b1b9a8db11129fd7603f1cb00bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a035a1760c40a956ae12cbaf5d1bb2d0a"><td class="memItemLeft" align="right" valign="top">virtual const double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#a035a1760c40a956ae12cbaf5d1bb2d0a">level</a> () const </td></tr>
<tr class="memdesc:a035a1760c40a956ae12cbaf5d1bb2d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the level of a <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>.  <a href="#a035a1760c40a956ae12cbaf5d1bb2d0a">More...</a><br /></td></tr>
<tr class="separator:a035a1760c40a956ae12cbaf5d1bb2d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4583adc77af00fdb17268e15f9e85734"><td class="memTemplParams" colspan="2">template&lt;class Function &gt; </td></tr>
<tr class="memitem:a4583adc77af00fdb17268e15f9e85734"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classfl_1_1_node.html">Node</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#a4583adc77af00fdb17268e15f9e85734">assignGrayLevelRec</a> (Function f)</td></tr>
<tr class="memdesc:a4583adc77af00fdb17268e15f9e85734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a scalar gray level to the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> and all its children.  <a href="#a4583adc77af00fdb17268e15f9e85734">More...</a><br /></td></tr>
<tr class="separator:a4583adc77af00fdb17268e15f9e85734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52599086b0c8bd75cf9e41e93d93b00"><td class="memTemplParams" colspan="2">template&lt;class Function &gt; </td></tr>
<tr class="memitem:af52599086b0c8bd75cf9e41e93d93b00"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classfl_1_1_node.html">Node</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#af52599086b0c8bd75cf9e41e93d93b00">assignHyperLevelRec</a> (Function f)</td></tr>
<tr class="memdesc:af52599086b0c8bd75cf9e41e93d93b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a vectorial gray level to the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> and all its children.  <a href="#af52599086b0c8bd75cf9e41e93d93b00">More...</a><br /></td></tr>
<tr class="separator:af52599086b0c8bd75cf9e41e93d93b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f8c0312e9fb0f6bc959f38c5cebcaa"><td class="memItemLeft" align="right" valign="top">virtual const int &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#ac0f8c0312e9fb0f6bc959f38c5cebcaa">grayLevel</a> () const </td></tr>
<tr class="memdesc:ac0f8c0312e9fb0f6bc959f38c5cebcaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the scalar gray level of a <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>.  <a href="#ac0f8c0312e9fb0f6bc959f38c5cebcaa">More...</a><br /></td></tr>
<tr class="separator:ac0f8c0312e9fb0f6bc959f38c5cebcaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b2fe6b301dc777c33556593d0f85c7f"><td class="memItemLeft" align="right" valign="top">virtual const std::vector&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#a9b2fe6b301dc777c33556593d0f85c7f">hyperGraylevel</a> () const </td></tr>
<tr class="memdesc:a9b2fe6b301dc777c33556593d0f85c7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the vectorial gray level of a <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>.  <a href="#a9b2fe6b301dc777c33556593d0f85c7f">More...</a><br /></td></tr>
<tr class="separator:a9b2fe6b301dc777c33556593d0f85c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6755ff88a98279929df4ad3d05ded1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#a6c6755ff88a98279929df4ad3d05ded1">colorMe</a> (cv::Mat &amp;img) const </td></tr>
<tr class="memdesc:a6c6755ff88a98279929df4ad3d05ded1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Color the corresponding elements in an image.  <a href="#a6c6755ff88a98279929df4ad3d05ded1">More...</a><br /></td></tr>
<tr class="separator:a6c6755ff88a98279929df4ad3d05ded1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd20a06247e2aac77927a2895f2b2f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#a4fd20a06247e2aac77927a2895f2b2f6">colorThem</a> (std::vector&lt; cv::Mat &gt; &amp;imgs) const </td></tr>
<tr class="memdesc:a4fd20a06247e2aac77927a2895f2b2f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Color the corresponding elements in a multichannel image.  <a href="#a4fd20a06247e2aac77927a2895f2b2f6">More...</a><br /></td></tr>
<tr class="separator:a4fd20a06247e2aac77927a2895f2b2f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cfbea98e4d84dad5a492e2f731c36d0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#a7cfbea98e4d84dad5a492e2f731c36d0">elementCount</a> (void)</td></tr>
<tr class="memdesc:a7cfbea98e4d84dad5a492e2f731c36d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of elements associated to the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>.  <a href="#a7cfbea98e4d84dad5a492e2f731c36d0">More...</a><br /></td></tr>
<tr class="separator:a7cfbea98e4d84dad5a492e2f731c36d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892bfb8b12826b9c6b5b23b7670ecc21"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#a892bfb8b12826b9c6b5b23b7670ecc21">nodeCount</a> (void)</td></tr>
<tr class="memdesc:a892bfb8b12826b9c6b5b23b7670ecc21"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>s in the subtree of this <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>.  <a href="#a892bfb8b12826b9c6b5b23b7670ecc21">More...</a><br /></td></tr>
<tr class="separator:a892bfb8b12826b9c6b5b23b7670ecc21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a8476dcafa58b63357df34eca94bbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfl_1_1_attribute.html">Attribute</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#a81a8476dcafa58b63357df34eca94bbf">getAttribute</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:a81a8476dcafa58b63357df34eca94bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve an <code><a class="el" href="classfl_1_1_attribute.html" title="Abstract Attribute, virtual interface to manipulate with all kinds of attributes. ...">Attribute</a></code> of a specific type.  <a href="#a81a8476dcafa58b63357df34eca94bbf">More...</a><br /></td></tr>
<tr class="separator:a81a8476dcafa58b63357df34eca94bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55784a8c408d709c706ee6fa279b85a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#a55784a8c408d709c706ee6fa279b85a4">getChildrenAttributes</a> (const std::string &amp;name, std::vector&lt; <a class="el" href="classfl_1_1_attribute.html">Attribute</a> * &gt; &amp;cat) const </td></tr>
<tr class="memdesc:a55784a8c408d709c706ee6fa279b85a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve children <code><a class="el" href="classfl_1_1_attribute.html" title="Abstract Attribute, virtual interface to manipulate with all kinds of attributes. ...">Attribute</a></code>s of a specific type.  <a href="#a55784a8c408d709c706ee6fa279b85a4">More...</a><br /></td></tr>
<tr class="separator:a55784a8c408d709c706ee6fa279b85a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c3c445b2e17e637dd8b030a8d38650"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfl_1_1_any_pattern_spectra2_d.html">AnyPatternSpectra2D</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#ac8c3c445b2e17e637dd8b030a8d38650">getPatternSpectra2D</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:ac8c3c445b2e17e637dd8b030a8d38650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve an <code><a class="el" href="classfl_1_1_pattern_spectra2_d.html" title="A concrete implementation of a pattern spectrum. The attributes to be used are specified by the speci...">PatternSpectra2D</a></code> of a specific type.  <a href="#ac8c3c445b2e17e637dd8b030a8d38650">More...</a><br /></td></tr>
<tr class="separator:ac8c3c445b2e17e637dd8b030a8d38650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc062fdd5ee17ed3a86fd873353a937"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#acdc062fdd5ee17ed3a86fd873353a937">getChildrenPatternSpectra2D</a> (const std::string &amp;name, std::vector&lt; <a class="el" href="classfl_1_1_any_pattern_spectra2_d.html">AnyPatternSpectra2D</a> * &gt; &amp;cps) const </td></tr>
<tr class="memdesc:acdc062fdd5ee17ed3a86fd873353a937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve children <code><a class="el" href="classfl_1_1_pattern_spectra2_d.html" title="A concrete implementation of a pattern spectrum. The attributes to be used are specified by the speci...">PatternSpectra2D</a></code>s of a specific type.  <a href="#acdc062fdd5ee17ed3a86fd873353a937">More...</a><br /></td></tr>
<tr class="separator:acdc062fdd5ee17ed3a86fd873353a937"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a27df793c25544d18f8d846911188e073"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#a27df793c25544d18f8d846911188e073">deleteChild</a> (int childIndex)</td></tr>
<tr class="memdesc:a27df793c25544d18f8d846911188e073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a child <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>.  <a href="#a27df793c25544d18f8d846911188e073">More...</a><br /></td></tr>
<tr class="separator:a27df793c25544d18f8d846911188e073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1c6cd99b2f42cbc383f32104ae427c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#acb1c6cd99b2f42cbc383f32104ae427c">checkConstraints</a> (void) const =0</td></tr>
<tr class="memdesc:acb1c6cd99b2f42cbc383f32104ae427c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the constraints according to <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> type are valid.  <a href="#acb1c6cd99b2f42cbc383f32104ae427c">More...</a><br /></td></tr>
<tr class="separator:acb1c6cd99b2f42cbc383f32104ae427c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc6344f1418f4b780025ca6839d0acc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#a0bc6344f1418f4b780025ca6839d0acc">setParent</a> (<a class="el" href="classfl_1_1_node.html">Node</a> *p)</td></tr>
<tr class="memdesc:a0bc6344f1418f4b780025ca6839d0acc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the parent of a <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>  <a href="#a0bc6344f1418f4b780025ca6839d0acc">More...</a><br /></td></tr>
<tr class="separator:a0bc6344f1418f4b780025ca6839d0acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a325115883b5823fb3fe8eaf0695b4564"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#a325115883b5823fb3fe8eaf0695b4564">getAllDescendants</a> (std::vector&lt; <a class="el" href="classfl_1_1_node.html">Node</a> * &gt; &amp;allNodes)</td></tr>
<tr class="memdesc:a325115883b5823fb3fe8eaf0695b4564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>s from the whole subtree of the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>.  <a href="#a325115883b5823fb3fe8eaf0695b4564">More...</a><br /></td></tr>
<tr class="separator:a325115883b5823fb3fe8eaf0695b4564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f9b9d141f33d2278f2185f54dcf181"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfl_1_1_attribute.html">Attribute</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#a96f9b9d141f33d2278f2185f54dcf181">addAttribute</a> (<a class="el" href="classfl_1_1_attribute.html">Attribute</a> *nat, const std::string &amp;name)</td></tr>
<tr class="memdesc:a96f9b9d141f33d2278f2185f54dcf181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a specific <code><a class="el" href="classfl_1_1_attribute.html" title="Abstract Attribute, virtual interface to manipulate with all kinds of attributes. ...">Attribute</a></code> to this <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>.  <a href="#a96f9b9d141f33d2278f2185f54dcf181">More...</a><br /></td></tr>
<tr class="separator:a96f9b9d141f33d2278f2185f54dcf181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c5094f22ae5340e9efab8c9bbfecd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfl_1_1_attribute.html">Attribute</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#a95c5094f22ae5340e9efab8c9bbfecd2">deleteAttribute</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a95c5094f22ae5340e9efab8c9bbfecd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a specific <code><a class="el" href="classfl_1_1_attribute.html" title="Abstract Attribute, virtual interface to manipulate with all kinds of attributes. ...">Attribute</a></code> from this <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>.  <a href="#a95c5094f22ae5340e9efab8c9bbfecd2">More...</a><br /></td></tr>
<tr class="separator:a95c5094f22ae5340e9efab8c9bbfecd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b3c6b75140b7caff493e4a9f3fcbe5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#ad5b3c6b75140b7caff493e4a9f3fcbe5">attributeExists</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:ad5b3c6b75140b7caff493e4a9f3fcbe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a specific <code><a class="el" href="classfl_1_1_attribute.html" title="Abstract Attribute, virtual interface to manipulate with all kinds of attributes. ...">Attribute</a></code> is assigned to this <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>.  <a href="#ad5b3c6b75140b7caff493e4a9f3fcbe5">More...</a><br /></td></tr>
<tr class="separator:ad5b3c6b75140b7caff493e4a9f3fcbe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675054e47b857641e51d149570cd5ed1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#a675054e47b857641e51d149570cd5ed1">addPatternSpectra2D</a> (<a class="el" href="classfl_1_1_any_pattern_spectra2_d.html">AnyPatternSpectra2D</a> *aps, const std::string &amp;name)</td></tr>
<tr class="memdesc:a675054e47b857641e51d149570cd5ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a specific <code>PatterSpectra2D</code> to this <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>.  <a href="#a675054e47b857641e51d149570cd5ed1">More...</a><br /></td></tr>
<tr class="separator:a675054e47b857641e51d149570cd5ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde096b5bdf441651f58ade8e5caf7fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfl_1_1_any_pattern_spectra2_d.html">AnyPatternSpectra2D</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#abde096b5bdf441651f58ade8e5caf7fb">deletePatternSpectra2D</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:abde096b5bdf441651f58ade8e5caf7fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a specific <code><a class="el" href="classfl_1_1_pattern_spectra2_d.html" title="A concrete implementation of a pattern spectrum. The attributes to be used are specified by the speci...">PatternSpectra2D</a></code> from this <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>.  <a href="#abde096b5bdf441651f58ade8e5caf7fb">More...</a><br /></td></tr>
<tr class="separator:abde096b5bdf441651f58ade8e5caf7fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb68970ff31b23de0e372ee5ba0c381"><td class="memItemLeft" align="right" valign="top">std::pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#a6eb68970ff31b23de0e372ee5ba0c381">minMaxLevel</a> (void) const </td></tr>
<tr class="memdesc:a6eb68970ff31b23de0e372ee5ba0c381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimal and maximal levels present in the sub-tree.  <a href="#a6eb68970ff31b23de0e372ee5ba0c381">More...</a><br /></td></tr>
<tr class="separator:a6eb68970ff31b23de0e372ee5ba0c381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a355af2e919b9c4eb7bb9f07d2a78615e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#a355af2e919b9c4eb7bb9f07d2a78615e">printElements</a> (std::ostream &amp;outStream=std::cout, int depth=0) const </td></tr>
<tr class="memdesc:a355af2e919b9c4eb7bb9f07d2a78615e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the subtree belonging to the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>.  <a href="#a355af2e919b9c4eb7bb9f07d2a78615e">More...</a><br /></td></tr>
<tr class="separator:a355af2e919b9c4eb7bb9f07d2a78615e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523e68d364b3e1edb984decea1b89e35"><td class="memTemplParams" colspan="2">template&lt;typename TAT &gt; </td></tr>
<tr class="memitem:a523e68d364b3e1edb984decea1b89e35"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename <br class="typebreak" />
TAT::attribute_type, typename <br class="typebreak" />
TAT::attribute_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#a523e68d364b3e1edb984decea1b89e35">minMaxAttribute</a> (void) const </td></tr>
<tr class="memdesc:a523e68d364b3e1edb984decea1b89e35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimal and maximal <code><a class="el" href="classfl_1_1_attribute.html" title="Abstract Attribute, virtual interface to manipulate with all kinds of attributes. ...">Attribute</a></code> value present in the sub-tree.  <a href="#a523e68d364b3e1edb984decea1b89e35">More...</a><br /></td></tr>
<tr class="separator:a523e68d364b3e1edb984decea1b89e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df5dfb3acc489f20f6b0b71a7431a2e"><td class="memTemplParams" colspan="2">template&lt;typename AT &gt; </td></tr>
<tr class="memitem:a4df5dfb3acc489f20f6b0b71a7431a2e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#a4df5dfb3acc489f20f6b0b71a7431a2e">printElementsWithAttribute</a> (std::ostream &amp;outStream=std::cout, int depth=0) const </td></tr>
<tr class="memdesc:a4df5dfb3acc489f20f6b0b71a7431a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the subtree belonging to the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> and their value of an <code><a class="el" href="classfl_1_1_attribute.html" title="Abstract Attribute, virtual interface to manipulate with all kinds of attributes. ...">Attribute</a></code>.  <a href="#a4df5dfb3acc489f20f6b0b71a7431a2e">More...</a><br /></td></tr>
<tr class="separator:a4df5dfb3acc489f20f6b0b71a7431a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a12345dced6e8bde9aa60d1d5e4840ff7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; int, <br class="typebreak" />
int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#a12345dced6e8bde9aa60d1d5e4840ff7">_S</a></td></tr>
<tr class="memdesc:a12345dced6e8bde9aa60d1d5e4840ff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of own elements.  <a href="#a12345dced6e8bde9aa60d1d5e4840ff7">More...</a><br /></td></tr>
<tr class="separator:a12345dced6e8bde9aa60d1d5e4840ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1799e119ad593baf495daf298103c5f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1799e119ad593baf495daf298103c5f4"></a>
std::vector&lt; <a class="el" href="classfl_1_1_node.html">Node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#a1799e119ad593baf495daf298103c5f4">_children</a></td></tr>
<tr class="memdesc:a1799e119ad593baf495daf298103c5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of children of the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>. <br /></td></tr>
<tr class="separator:a1799e119ad593baf495daf298103c5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecfb3323d7f59b0ea201d8d0b0c6894a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfl_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#aecfb3323d7f59b0ea201d8d0b0c6894a">_parent</a></td></tr>
<tr class="memdesc:aecfb3323d7f59b0ea201d8d0b0c6894a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pointer to the parent <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>.  <a href="#aecfb3323d7f59b0ea201d8d0b0c6894a">More...</a><br /></td></tr>
<tr class="separator:aecfb3323d7f59b0ea201d8d0b0c6894a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15df3d9a3b3b93da31126ab46bf02340"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#a15df3d9a3b3b93da31126ab46bf02340">_level</a></td></tr>
<tr class="memdesc:a15df3d9a3b3b93da31126ab46bf02340"><td class="mdescLeft">&#160;</td><td class="mdescRight">The level of the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> in the hierarchy.  <a href="#a15df3d9a3b3b93da31126ab46bf02340">More...</a><br /></td></tr>
<tr class="separator:a15df3d9a3b3b93da31126ab46bf02340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2893b663163e4232728ad2e5a5cc3cba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#a2893b663163e4232728ad2e5a5cc3cba">_grayLevel</a></td></tr>
<tr class="memdesc:a2893b663163e4232728ad2e5a5cc3cba"><td class="mdescLeft">&#160;</td><td class="mdescRight">The gray level of the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>.  <a href="#a2893b663163e4232728ad2e5a5cc3cba">More...</a><br /></td></tr>
<tr class="separator:a2893b663163e4232728ad2e5a5cc3cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac903e3f752e49e80083be6a16a45d103"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#ac903e3f752e49e80083be6a16a45d103">_hgrayLevels</a></td></tr>
<tr class="memdesc:ac903e3f752e49e80083be6a16a45d103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorial gray levels of the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>  <a href="#ac903e3f752e49e80083be6a16a45d103">More...</a><br /></td></tr>
<tr class="separator:ac903e3f752e49e80083be6a16a45d103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b6785bf14804ad6b5e3effe116f1c86"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#a7b6785bf14804ad6b5e3effe116f1c86">sizeKnown</a></td></tr>
<tr class="memdesc:a7b6785bf14804ad6b5e3effe116f1c86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicator value of size.  <a href="#a7b6785bf14804ad6b5e3effe116f1c86">More...</a><br /></td></tr>
<tr class="separator:a7b6785bf14804ad6b5e3effe116f1c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b299817f904b877dc9df97ceba9831"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#ad7b299817f904b877dc9df97ceba9831">ncountKnown</a></td></tr>
<tr class="memdesc:ad7b299817f904b877dc9df97ceba9831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicator value for node count.  <a href="#ad7b299817f904b877dc9df97ceba9831">More...</a><br /></td></tr>
<tr class="separator:ad7b299817f904b877dc9df97ceba9831"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a24ba39949e42251f633e22cc7622545b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24ba39949e42251f633e22cc7622545b"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>ImageTree</b></td></tr>
<tr class="separator:a24ba39949e42251f633e22cc7622545b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54044933b8dfc4cba3df7dabda467365"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a54044933b8dfc4cba3df7dabda467365"></a>
std::pair&lt; int, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mserRecursive</b> (<a class="el" href="classfl_1_1_node.html">Node</a> *root, const int deltaLvl, std::vector&lt; <a class="el" href="classfl_1_1_node.html">Node</a> * &gt; &amp;mserOrder, int minArea, double maxVariation)</td></tr>
<tr class="separator:a54044933b8dfc4cba3df7dabda467365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96703cbb4d7455935ba5e28d73e769e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac96703cbb4d7455935ba5e28d73e769e"></a>
std::pair&lt; int, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mserRecursive</b> (<a class="el" href="classfl_1_1_node.html">Node</a> *root, const int deltaLvl, std::vector&lt; <a class="el" href="classfl_1_1_node.html">Node</a> * &gt; &amp;mserOrder, std::vector&lt; std::pair&lt; double, int &gt; &gt; &amp;div, int minArea, double maxVariation)</td></tr>
<tr class="separator:ac96703cbb4d7455935ba5e28d73e769e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8feb9ebfc9ce706e4ddfe107af494b4f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8feb9ebfc9ce706e4ddfe107af494b4f"></a>
<a class="el" href="classfl_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>constructRecursively</b> (<a class="el" href="classfl_1_1_node.html">Node</a> *root, std::vector&lt; std::vector&lt; char &gt; &gt; &amp;seen)</td></tr>
<tr class="separator:a8feb9ebfc9ce706e4ddfe107af494b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd05cccabee0ffec4485522c899ae2dd"><td class="memTemplParams" colspan="2">template&lt;typename Compare &gt; </td></tr>
<tr class="memitem:acd05cccabee0ffec4485522c899ae2dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classfl_1_1_node.html">Node</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfl_1_1_node.html#acd05cccabee0ffec4485522c899ae2dd">maxTreeNister</a> (const cv::Mat &amp;img, Compare pxOrder=std::less&lt; int &gt;(), <a class="el" href="namespacefl.html#ab9df0ac37a93c4c1b24f18cc6a33aa1d">pxType</a> curType=regular)</td></tr>
<tr class="memdesc:acd05cccabee0ffec4485522c899ae2dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the max-tree using algorithm from: D. Nister, H. Stewenius: "Linear time
maximally stable extremal regions" (2008).  <a href="#acd05cccabee0ffec4485522c899ae2dd">More...</a><br /></td></tr>
<tr class="separator:acd05cccabee0ffec4485522c899ae2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c730ab7ba9851572c2fc20e8a504ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91c730ab7ba9851572c2fc20e8a504ca"></a>
std::pair&lt; int, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>areaDiff</b> (<a class="el" href="classfl_1_1_node.html">Node</a> *root, const int deltaLvl)</td></tr>
<tr class="separator:a91c730ab7ba9851572c2fc20e8a504ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Abstract <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>, single element of a component tree. </p>
<p>This class provides general functionality of a <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>, provides access and manipulation functions. Each <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> contains it's own elements (pixels) and the elements of it's children. No assumption on own elements or number of children is made here.</p>
<dl class="section note"><dt>Note</dt><dd>To use, a concrete class <a class="el" href="classfl_1_1_partitioning_node.html" title="PartitioningNode is a single element of any partitioning component tree. ">PartitioningNode</a> or <a class="el" href="classfl_1_1_inclusion_node.html" title="InclusionNode is a single element of any inclusion component tree. ">InclusionNode</a> needs to be used. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a2c866c99680f0f89fb3619169530a023"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Node::Node </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor assigning pixels to the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>. </p>
<p>Constructor initializing internal <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> elements (pixels).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>An array of pixel coordinates </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a364d627759d8a35aebfd196a12a09943"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Node::Node </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classfl_1_1_node.html">Node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>children</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor assigning both pixels and all children to the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>. </p>
<p>Constructor initializing internal <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> elements (pixels), as well as the list of children.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>An array of pixel coordinates </td></tr>
    <tr><td class="paramname">children</td><td>An array of pointers to children of type <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>All children in <code>children</code> have to be of the same type </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a96f9b9d141f33d2278f2185f54dcf181"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfl_1_1_attribute.html">Attribute</a> * Node::addAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfl_1_1_attribute.html">Attribute</a> *&#160;</td>
          <td class="paramname"><em>nat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a specific <code><a class="el" href="classfl_1_1_attribute.html" title="Abstract Attribute, virtual interface to manipulate with all kinds of attributes. ...">Attribute</a></code> to this <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>. </p>
<p>The function will take care of assigning multiple copies of <code><a class="el" href="classfl_1_1_attribute.html" title="Abstract Attribute, virtual interface to manipulate with all kinds of attributes. ...">Attribute</a></code> to the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>. A corresponding <code><a class="el" href="classfl_1_1_node.html#a95c5094f22ae5340e9efab8c9bbfecd2" title="Delete a specific Attribute from this Node. ">deleteAttribute()</a></code> must be called for each call to this function.</p>
<dl class="section note"><dt>Note</dt><dd>This should eventually allow to change the <code><a class="el" href="classfl_1_1_attribute_settings.html" title="Virtual interface to implement all the settings required for a specific type of Attribute. ">AttributeSettings</a></code> associated with each assigned copy.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is used through <code><a class="el" href="classfl_1_1_image_tree.html#a5e39234d95ff83864a1ee060b1731c0d" title="Assign a specific Attribute to this ImageTree. ">ImageTree::addAttributeToTree()</a></code> which ensures the correctness of input parameters.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nat</td><td>An <code><a class="el" href="classfl_1_1_attribute.html" title="Abstract Attribute, virtual interface to manipulate with all kinds of attributes. ...">Attribute</a> *</code> to the specific attribute to assign to the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>.</td></tr>
    <tr><td class="paramname">name</td><td>The static identifier <code>name</code> assigned to the desired specific attribute. Example: <code>AreaAttribute::name</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the <code><a class="el" href="classfl_1_1_attribute.html" title="Abstract Attribute, virtual interface to manipulate with all kinds of attributes. ...">Attribute</a></code> was already assigned to the node, returns a pointer to that copy of the <code><a class="el" href="classfl_1_1_attribute.html" title="Abstract Attribute, virtual interface to manipulate with all kinds of attributes. ...">Attribute</a></code>. <code>NULL</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Do I lose memory here when I forget the old attribute? </dd></dl>

</div>
</div>
<a class="anchor" id="a858d389047b889525fb20adcf0fe62b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::addChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfl_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign a child <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>. </p>
<p>Assigns a child <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> to this <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>. Also checks for constraint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>A pointer to the new child <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function will also check if the new child <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> does not violate any constraint about general <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> structure (e.g. containing the same pixel twice) or specific constraints coming from specific <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> type. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The child <code>ch</code> has to be of the same type as the parent <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>.</dd>
<dd>
Invalidates the values stored by:<ul>
<li><code><a class="el" href="classfl_1_1_node.html#a7cfbea98e4d84dad5a492e2f731c36d0" title="The number of elements associated to the Node. ">elementCount()</a></code></li>
<li><code><a class="el" href="classfl_1_1_node.html#a892bfb8b12826b9c6b5b23b7670ecc21" title="The number of Nodes in the subtree of this Node. ">nodeCount()</a></code> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a5270dac7d9e9ea39b09fd7b38d7851a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::addElement </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; int, int &gt; &amp;&#160;</td>
          <td class="paramname"><em>px</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a single element to this <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>. </p>
<p>Assign a pixel with coordinates as an element of this <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">px</td><td>Coordinates to the new pixel element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function will also check if the new child <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> does not violate any constraint about general <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> structure (e.g. containing the same pixel twice) or specific constraints coming from specific <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> type.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Invalidates the values stored by:<ul>
<li><code><a class="el" href="classfl_1_1_node.html#a7cfbea98e4d84dad5a492e2f731c36d0" title="The number of elements associated to the Node. ">elementCount()</a></code> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a675054e47b857641e51d149570cd5ed1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Node::addPatternSpectra2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfl_1_1_any_pattern_spectra2_d.html">AnyPatternSpectra2D</a> *&#160;</td>
          <td class="paramname"><em>aps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a specific <code>PatterSpectra2D</code> to this <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>. </p>
<p>The function will only assign a new specific <code><a class="el" href="classfl_1_1_pattern_spectra2_d.html" title="A concrete implementation of a pattern spectrum. The attributes to be used are specified by the speci...">PatternSpectra2D</a></code> to the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> if is was not previously assigned to the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>.</p>
<dl class="section note"><dt>Note</dt><dd>A corresponding call to <code><a class="el" href="classfl_1_1_node.html#abde096b5bdf441651f58ade8e5caf7fb" title="Delete a specific PatternSpectra2D from this Node. ">deletePatternSpectra2D()</a></code> should be done for every call to this function.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is used through <code><a class="el" href="classfl_1_1_image_tree.html#a26f61a586d8a68a0a9e95d79615f1ad6" title="Assign a PatternSpectra2D based on two specific Attributes to this ImageTree. ">ImageTree::addPatternSpectra2DToTree()</a></code> which ensures the correctness of input parameters.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aps</td><td>An <code>AnyPatternSpectra *</code> to the specific pattern spectrum to assign to the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>.</td></tr>
    <tr><td class="paramname">name</td><td>The concatenation of static identifiers <code>name</code> assigned to the desired specific attribute. Example:<ul>
<li><code>AreaAttribute::name + RangeAttribute::name</code></li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the specific <code><a class="el" href="classfl_1_1_pattern_spectra2_d.html" title="A concrete implementation of a pattern spectrum. The attributes to be used are specified by the speci...">PatternSpectra2D</a></code> was already assigned to the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> returns <code>false</code> (and does not perform assignment). Otherwise, returns <code>true</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a4583adc77af00fdb17268e15f9e85734"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Function &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfl_1_1_node.html">Node</a> * Node::assignGrayLevelRec </td>
          <td>(</td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign a scalar gray level to the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> and all its children. </p>
<p>The gray level is assigned based on the function <code>f</code> and the elements associated to the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>To be used when the gray level of a <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> is a scalar value (i.e. hierarchies from single channel images). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the used function <code>f</code> requires the values of elements associated with the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>, the user needs to ensure that an image is associated with the hierarchy with <a class="el" href="classfl_1_1_image_tree.html#a100c96a5e8dcdd8bccc2c047d98656a9" title="Sets the image. ">ImageTree::setImage()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function used to calculate and assign the gray level. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af52599086b0c8bd75cf9e41e93d93b00"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Function &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfl_1_1_node.html">Node</a> * Node::assignHyperLevelRec </td>
          <td>(</td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign a vectorial gray level to the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> and all its children. </p>
<p>The gray level is assigned based on the function <code>f</code> and the elements associated to the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>To be used when the gray level of a <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> is a vector value (i.e. hierarchies from multichannel images).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the used function <code>f</code> requires the values of elements associated with the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>, the user needs to ensure that an image is associated with the hierarchy with <a class="el" href="classfl_1_1_image_tree.html#ab32ada677d46a3a2a530824342a37133" title="Sets the multichannel image. ">ImageTree::setImages()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function used to calculate and assign the gray level. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af243b1b9a8db11129fd7603f1cb00bbc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::assignLevel </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a <code>level</code> to the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Even though most hierarchies operate with levels of integral type (i.e. integers), the <code>level</code> can be any scalar (double value).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Depending on the action performed, only the integral part of the level might be considered.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>The new level to be assigned. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classfl_1_1_inclusion_node.html#aa3be0979e0b85b4e7657f45529d5aa04">fl::InclusionNode</a>.</p>

</div>
</div>
<a class="anchor" id="ad5b3c6b75140b7caff493e4a9f3fcbe5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Node::attributeExists </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a specific <code><a class="el" href="classfl_1_1_attribute.html" title="Abstract Attribute, virtual interface to manipulate with all kinds of attributes. ...">Attribute</a></code> is assigned to this <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The static identifier <code>name</code> assigned to the desired specific attribute. Example: <code>AreaAttribute::name</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acb1c6cd99b2f42cbc383f32104ae427c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void fl::Node::checkConstraints </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the constraints according to <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> type are valid. </p>
<p>Virtual function to be implemented for each specific <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> type. </p>

<p>Implemented in <a class="el" href="classfl_1_1_inclusion_node.html#a84f9b47b17f7d1f57a2107f53a9cb1e0">fl::InclusionNode</a>, and <a class="el" href="classfl_1_1_partitioning_node.html#a791ee83b3260ebf37b71843c03fbef87">fl::PartitioningNode</a>.</p>

</div>
</div>
<a class="anchor" id="a6c6755ff88a98279929df4ad3d05ded1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::colorMe </td>
          <td>(</td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>img</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Color the corresponding elements in an image. </p>
<p>Colors the elements (pixels) of the provided image which correspond by coordinates to the current <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> elements with the appropriate gray level (determined by the gray level of the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>) and it's children.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>The image to be colored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>To be used when the gray level of a <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> is a scalar value (i.e. hierarchies from single channel images).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Behavior might not be implemented for all scalar types. </dd></dl>

</div>
</div>
<a class="anchor" id="a4fd20a06247e2aac77927a2895f2b2f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::colorThem </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; cv::Mat &gt; &amp;&#160;</td>
          <td class="paramname"><em>imgs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Color the corresponding elements in a multichannel image. </p>
<p>Colors the elements (pixels) on all the provided image channels which correspond by coordinates to the current <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> elements with the appropriate vectorial values (determined by the vectorial gray level of a <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>) and it's children.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">imgs</td><td>The channels of the multichannel image to be colored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>To be used when the gray level of a <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> is a vector value (i.e. hierarchies from multichannel images). </dd></dl>

</div>
</div>
<a class="anchor" id="a95c5094f22ae5340e9efab8c9bbfecd2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfl_1_1_attribute.html">Attribute</a> * Node::deleteAttribute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete a specific <code><a class="el" href="classfl_1_1_attribute.html" title="Abstract Attribute, virtual interface to manipulate with all kinds of attributes. ...">Attribute</a></code> from this <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>. </p>
<p>The function will take care of multiple assigned copies of <code><a class="el" href="classfl_1_1_attribute.html" title="Abstract Attribute, virtual interface to manipulate with all kinds of attributes. ...">Attribute</a></code> to the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>. One call to this function must be made for each call to <code><a class="el" href="classfl_1_1_node.html#a96f9b9d141f33d2278f2185f54dcf181" title="Assign a specific Attribute to this Node. ">addAttribute()</a></code></p>
<dl class="section note"><dt>Note</dt><dd>This should eventually take care of the <code><a class="el" href="classfl_1_1_attribute_settings.html" title="Virtual interface to implement all the settings required for a specific type of Attribute. ">AttributeSettings</a></code> associated with each assigned copy.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is used through <code><a class="el" href="classfl_1_1_image_tree.html#a099475393768f9ca88f1b345c59aa5f5" title="Delete a specific Attribute from this ImageTree. ">ImageTree::deleteAttributeFromTree()</a></code> which ensures the correctness of input parameters.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The static identifier <code>name</code> assigned to the desired specific attribute. Example: <code>AreaAttribute::name</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If this was the last copy of the <code><a class="el" href="classfl_1_1_attribute.html" title="Abstract Attribute, virtual interface to manipulate with all kinds of attributes. ...">Attribute</a></code> assigned to the node, returns a pointer to that copy of the <code><a class="el" href="classfl_1_1_attribute.html" title="Abstract Attribute, virtual interface to manipulate with all kinds of attributes. ...">Attribute</a></code>. <code>NULL</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a27df793c25544d18f8d846911188e073"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::deleteChild </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>childIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete a child <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>. </p>
<p>Deletes a child from this node. Does not check for constraints. This function will assign all the elements (pixels) directly belonging to the child <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> being deleted to the parent <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>. Also, all children of the child <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> become the children of the parent <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">childIndex</td><td>The index of the child to be deleted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function invalidates <code><a class="el" href="classfl_1_1_node.html#ad7b299817f904b877dc9df97ceba9831" title="Indicator value for node count. ">Node::ncountKnown</a></code> and triggers a recalculation at next call to <code><a class="el" href="classfl_1_1_node.html#a892bfb8b12826b9c6b5b23b7670ecc21" title="The number of Nodes in the subtree of this Node. ">nodeCount()</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="abde096b5bdf441651f58ade8e5caf7fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfl_1_1_any_pattern_spectra2_d.html">AnyPatternSpectra2D</a> * Node::deletePatternSpectra2D </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete a specific <code><a class="el" href="classfl_1_1_pattern_spectra2_d.html" title="A concrete implementation of a pattern spectrum. The attributes to be used are specified by the speci...">PatternSpectra2D</a></code> from this <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>. </p>
<p>One call to this function must be made for each call to <code><a class="el" href="classfl_1_1_node.html#a675054e47b857641e51d149570cd5ed1" title="Assign a specific PatterSpectra2D to this Node. ">addPatternSpectra2D()</a></code></p>
<dl class="section remark"><dt>Remarks</dt><dd>This function is used through <code><a class="el" href="classfl_1_1_image_tree.html#a4dc2f5deefc9fd941c22503a36681d2c" title="Delete a PatternSpectra2D based on two specific Attributes from this ImageTree. ">ImageTree::deletePatternSpectra2DFromTree()</a></code> which ensures the correctness of input parameters.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The concatenation of static identifiers <code>name</code> assigned to the desired specific attribute. Example:<ul>
<li><code>AreaAttribute::name + RangeAttribute::name</code></li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If a copy of the specific <code><a class="el" href="classfl_1_1_pattern_spectra2_d.html" title="A concrete implementation of a pattern spectrum. The attributes to be used are specified by the speci...">PatternSpectra2D</a></code> was assigned to the node, returns a <code><a class="el" href="classfl_1_1_any_pattern_spectra2_d.html" title="Abstract PatternSpectra2D, virtual interface not specifying the attributes used to build th Pattern S...">AnyPatternSpectra2D</a> *</code> to that copy of the pattern spectrum. <code>NULL</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a7cfbea98e4d84dad5a492e2f731c36d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Node::elementCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of elements associated to the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>. </p>
<p>Includes the elements (pixels) of all the children as well as all the elements of this <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>Number of elements of the <a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a>.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The function uses stores the calculation results and only repeats the calculation if certain actions have occurred between the consecutive calls of this function. These functions are:<ul>
<li><code><a class="el" href="classfl_1_1_node.html#a858d389047b889525fb20adcf0fe62b7" title="Assign a child Node. ">addChild()</a></code></li>
<li><code><a class="el" href="classfl_1_1_node.html#a5270dac7d9e9ea39b09fd7b38d7851a0" title="Add a single element to this Node. ">addElement()</a></code></li>
</ul>
</dd>
<dd>
Otherwise, consecutive calls to this function run in O(1). </dd></dl>

</div>
</div>
<a class="anchor" id="a325115883b5823fb3fe8eaf0695b4564"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::getAllDescendants </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classfl_1_1_node.html">Node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>allNodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>s from the whole subtree of the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allNodes</td><td>The array to be filled with all the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a> *</code> to all the descendant nodes from the subtree of the current <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The new <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a> *</code> will be appended to the end of <code>allNodes</code> (i.e. the old elements will not be erased in case <code>allNodes</code> is not empty. </dd></dl>

</div>
</div>
<a class="anchor" id="a81a8476dcafa58b63357df34eca94bbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfl_1_1_attribute.html">Attribute</a> * Node::getAttribute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve an <code><a class="el" href="classfl_1_1_attribute.html" title="Abstract Attribute, virtual interface to manipulate with all kinds of attributes. ...">Attribute</a></code> of a specific type. </p>
<p>The specific attribute is manipulated through the abstract <code><a class="el" href="classfl_1_1_attribute.html" title="Abstract Attribute, virtual interface to manipulate with all kinds of attributes. ...">Attribute</a></code> interface. To specify the desired specific attribute, the static identifier <code>SpecificAttribute::name</code> assigned for every attribute should be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The static identifier <code>name</code> assigned to the desired specific attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <code><a class="el" href="classfl_1_1_attribute.html" title="Abstract Attribute, virtual interface to manipulate with all kinds of attributes. ...">Attribute</a> *</code> to the specific attribute required. Should be cast to the appropriate pointer type for further manipulation. </dd></dl>

</div>
</div>
<a class="anchor" id="a55784a8c408d709c706ee6fa279b85a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::getChildrenAttributes </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classfl_1_1_attribute.html">Attribute</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>cat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve children <code><a class="el" href="classfl_1_1_attribute.html" title="Abstract Attribute, virtual interface to manipulate with all kinds of attributes. ...">Attribute</a></code>s of a specific type. </p>
<p>The specific attribute is manipulated through the abstract <code><a class="el" href="classfl_1_1_attribute.html" title="Abstract Attribute, virtual interface to manipulate with all kinds of attributes. ...">Attribute</a></code> interface. To specify the desired specific attribute, the static identifier <code>SpecificAttribute::name</code> assigned for every attribute should be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The static identifier <code>name</code> assigned to the desired specific attribute.</td></tr>
    <tr><td class="paramname">cat</td><td>The array to be filled with the children <code><a class="el" href="classfl_1_1_attribute.html" title="Abstract Attribute, virtual interface to manipulate with all kinds of attributes. ...">Attribute</a></code>s. Upon return, contains an <code><a class="el" href="classfl_1_1_attribute.html" title="Abstract Attribute, virtual interface to manipulate with all kinds of attributes. ...">Attribute</a> *</code> for each child to the specific attribute required. They should be cast to the appropriate pointer type for further manipulation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acdc062fdd5ee17ed3a86fd873353a937"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::getChildrenPatternSpectra2D </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classfl_1_1_any_pattern_spectra2_d.html">AnyPatternSpectra2D</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>cps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve children <code><a class="el" href="classfl_1_1_pattern_spectra2_d.html" title="A concrete implementation of a pattern spectrum. The attributes to be used are specified by the speci...">PatternSpectra2D</a></code>s of a specific type. </p>
<p>The specific attributes are specified by their static identifier <code>SpecificAttribute::name</code> assigned for every attribute.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The concatenation of static identifiers <code>name</code> assigned to the desired specific attribute. Example:<ul>
<li><code>AreaAttribute::name + RangeAttribute::name</code></li>
</ul>
</td></tr>
    <tr><td class="paramname">cps</td><td>The array to be filled with the children <code><a class="el" href="classfl_1_1_pattern_spectra2_d.html" title="A concrete implementation of a pattern spectrum. The attributes to be used are specified by the speci...">PatternSpectra2D</a></code>s. Upon return, contains an <code>AnyPatternSpectra *</code> for each child for the specific pattern spectra required. They should be cast to the appropriate pointer type for further manipulation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3c16de5d62ba24897226bfe957d327a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::getElements </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>px</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all the pixels of the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>. </p>
<p>Get all the elements (pixel coordinates) belonging this <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> (children pixel coordinates included).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">px</td><td>An array to fill with the coordinates of the pixel elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6fca7edd7d958f8e5177f2e8fdddc157"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp; Node::getOwnElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all self-pixels of the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>. </p>
<p>Get all the elements (pixel coordinates) added to the hierarchy at this specific <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> (children pixel coordinates not included).</p>
<dl class="section return"><dt>Returns</dt><dd>An array filled with the coordinates of the pixel elements. </dd></dl>

</div>
</div>
<a class="anchor" id="ac8c3c445b2e17e637dd8b030a8d38650"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfl_1_1_any_pattern_spectra2_d.html">AnyPatternSpectra2D</a> * Node::getPatternSpectra2D </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve an <code><a class="el" href="classfl_1_1_pattern_spectra2_d.html" title="A concrete implementation of a pattern spectrum. The attributes to be used are specified by the speci...">PatternSpectra2D</a></code> of a specific type. </p>
<p>The specific attributes are specified by their static identifier <code>SpecificAttribute::name</code> assigned for every attribute.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The concatenation of static identifiers <code>name</code> assigned to the desired specific attribute. Example:<ul>
<li><code>AreaAttribute::name + RangeAttribute::name</code></li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <code><a class="el" href="classfl_1_1_any_pattern_spectra2_d.html" title="Abstract PatternSpectra2D, virtual interface not specifying the attributes used to build th Pattern S...">AnyPatternSpectra2D</a> *</code> to the specific pattern spectrum requested. Should be cast to the appropriate pointer type for further manipulation. </dd></dl>

</div>
</div>
<a class="anchor" id="ac0f8c0312e9fb0f6bc959f38c5cebcaa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int &amp; Node::grayLevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the scalar gray level of a <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>To be used when the gray level of a <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> is a scalar value (i.e. hierarchies from single channel images).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The gray level of the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a9b2fe6b301dc777c33556593d0f85c7f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; int &gt; &amp; Node::hyperGraylevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the vectorial gray level of a <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>To be used when the gray level of a <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> is a vector value (i.e. hierarchies from multichannel images).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of gray levels of the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="af5e3b3ac0f3ab959cb15c351bd6f14b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Node::isRoot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> is a root <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> is a root <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a035a1760c40a956ae12cbaf5d1bb2d0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double &amp; Node::level </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the level of a <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Even though most hierarchies operate with levels of integral type (i.e. integers), the <code>level</code> can be any scalar (double value).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The level of the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a523e68d364b3e1edb984decea1b89e35"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename TAT::attribute_type, typename TAT::attribute_type &gt; Node::minMaxAttribute </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the minimal and maximal <code><a class="el" href="classfl_1_1_attribute.html" title="Abstract Attribute, virtual interface to manipulate with all kinds of attributes. ...">Attribute</a></code> value present in the sub-tree. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAT</td><td>A specific <code><a class="el" href="classfl_1_1_attribute.html" title="Abstract Attribute, virtual interface to manipulate with all kinds of attributes. ...">Attribute</a></code> class to be used in the search. Any specific <code><a class="el" href="classfl_1_1_typed_attribute.html" title="Virtual interface to manipulate with all kinds of attributes, defining the type of Attribute value...">TypedAttribute</a></code> where the <code><a class="el" href="classfl_1_1_typed_attribute.html#ab69a10dae12f70c7fe82a66b5e46de11" title="Returns the value of this Attribute ">TypedAttribute::value()</a></code> returns a scalar types can be used (e.g. <code><a class="el" href="classfl_1_1_area_attribute.html" title="Value of this Attribute corresponds to the area (number of pixels) of the Node. ">AreaAttribute</a></code>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair made of the minimum and maximum level value of the specific <code><a class="el" href="classfl_1_1_attribute.html" title="Abstract Attribute, virtual interface to manipulate with all kinds of attributes. ...">Attribute</a></code> within the sub-tree of this <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a6eb68970ff31b23de0e372ee5ba0c381"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; double, double &gt; Node::minMaxLevel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the minimal and maximal levels present in the sub-tree. </p>
<dl class="section return"><dt>Returns</dt><dd>A pair made of the minimum and maximum level value within the sub-tree of this <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a892bfb8b12826b9c6b5b23b7670ecc21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Node::nodeCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>s in the subtree of this <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>s in the subtree.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The function uses stores the calculation results and only repeats the calculation if certain actions have occurred between the consecutive calls of this function. These functions are:<ul>
<li><code><a class="el" href="classfl_1_1_node.html#a858d389047b889525fb20adcf0fe62b7" title="Assign a child Node. ">addChild()</a></code></li>
<li><code><a class="el" href="classfl_1_1_node.html#a27df793c25544d18f8d846911188e073" title="Delete a child Node. ">deleteChild()</a></code></li>
</ul>
</dd>
<dd>
Otherwise, consecutive calls to this function run in O(1). </dd></dl>

</div>
</div>
<a class="anchor" id="ad55b74418c40b3c1eeb9dfa372579e4f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfl_1_1_node.html">Node</a> * Node::parent </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>1</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a parent or ancestral <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>. </p>
<p>Allows to access an ancestral <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> removed for <code>depth</code> steps from the current <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depth</td><td>The number of links between the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> and it's returned parent. Optional parameter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the parent of this <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>. The parent will be <code>depth</code> steps removed from the original <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Calling this function without a parameter and using the default <code>depth</code> = 1 returns the direct parent of the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="a64a3448e33ea25261c66c7c23185dee5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfl_1_1_node.html">Node</a> * Node::parentBySize </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>perc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>oriSize</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>jumps</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a parent or ancestral <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> determined by it's size. </p>
<p>Allows to access an ancestral <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> which is the largest one in the hierarchy with the area no larger than <code>perc</code> *100 percent of the original <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> area (or a specified reference area).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perc</td><td>The maximal allowed area increase factor.</td></tr>
    <tr><td class="paramname">oriSize</td><td>Reference size (before the increase). To compare to the original <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> size in the hierarchy, omit this parameter. <br />
<em>This parameter is optional and not meant to be used for standard functionality of this function.</em></td></tr>
    <tr><td class="paramname">jumps</td><td>Internal parameter to keep track of the number of steps between the original <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> and the considered ancestor. <br />
<em>This parameter should be <em>omitted</em> when the function is used for its standard functionality.</em></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the appropriate parent or ancestral <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ad6fced27be60dc410a9f3ab7b0b2ae21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::parentBySize </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>perc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classfl_1_1_node.html">Node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>pathBetween</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>oriSize</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>jumps</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of ancestral <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>s of a <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>, up to the ancestral <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> larger than a size limit. </p>
<p>Allows to access an ancestral <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> which is the largest one in the hierarchy with the area no larger than <code>perc</code> *100 percent of the original <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> area (or a specified reference area). Returns the whole path between the original <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> and its ancestor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perc</td><td>The maximal allowed area increase factor.</td></tr>
    <tr><td class="paramname">pathBetween</td><td>An array which will contain the pointers to the ancestral <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>s in order from the closest to the farthest one in the hierarchy after the function executes. The last element of the array will be equal to the return value of the the sister function <code><a class="el" href="classfl_1_1_node.html#a64a3448e33ea25261c66c7c23185dee5" title="Get a parent or ancestral Node determined by it&#39;s size. ">parentBySize(double perc, int oriSize, int jumps)</a></code></td></tr>
    <tr><td class="paramname">oriSize</td><td>Reference size (before the increase). To compare to the original <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> size in the hierarchy, omit this parameter. <br />
<em>This parameter is optional and not meant to be used for standard functionality of this function.</em></td></tr>
    <tr><td class="paramname">jumps</td><td>Internal parameter to keep track of the number of steps between the original <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> and the considered ancestor. <br />
<em>This parameter <em>should be omitted</em> when the function is used for its standard functionality.</em> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a355af2e919b9c4eb7bb9f07d2a78615e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::printElements </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>outStream</em> = <code>std::cout</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the subtree belonging to the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>. </p>
<dl class="section note"><dt>Note</dt><dd>All the parameters are optional.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outStream</td><td>The output stream to which the data should be printed. By default, it equals to <code>std::cout</code>.</td></tr>
    <tr><td class="paramname">depth</td><td>The current depth in the tree. Corresponds to the amount of indentation printed before the information for that <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>. By default, it equals (0) (i.e. first <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> information not indented).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Prints the number and a list of elements (pixels) associated directly to each <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>, as well as the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>'s level and gray level. </dd></dl>

</div>
</div>
<a class="anchor" id="a4df5dfb3acc489f20f6b0b71a7431a2e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fl::Node::printElementsWithAttribute </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>outStream</em> = <code>std::cout</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the subtree belonging to the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> and their value of an <code><a class="el" href="classfl_1_1_attribute.html" title="Abstract Attribute, virtual interface to manipulate with all kinds of attributes. ...">Attribute</a></code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">AT</td><td>The specific <code><a class="el" href="classfl_1_1_typed_attribute.html" title="Virtual interface to manipulate with all kinds of attributes, defining the type of Attribute value...">TypedAttribute</a></code> which is to be printed along the subtree. The <code><a class="el" href="classfl_1_1_typed_attribute.html#ab69a10dae12f70c7fe82a66b5e46de11" title="Returns the value of this Attribute ">TypedAttribute::value()</a></code> must be printable to a stream.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>All the parameters are optional.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outStream</td><td>The output stream to which the data should be printed. By default, it equals to <code>std::cout</code>.</td></tr>
    <tr><td class="paramname">depth</td><td>The current depth in the tree. Corresponds to the amount of indentation printed before the information for that <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>. By default, it equals (0) (i.e. first <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> information not indented).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Prints the number and a list of elements (pixels) associated directly to each <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>, as well as the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>'s level and <code><a class="el" href="classfl_1_1_typed_attribute.html#ab69a10dae12f70c7fe82a66b5e46de11" title="Returns the value of this Attribute ">TypedAttribute::value()</a></code> associated to each node. </dd></dl>

</div>
</div>
<a class="anchor" id="a0bc6344f1418f4b780025ca6839d0acc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setParent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfl_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the parent of a <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td><code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a> *</code> pointer to a new parent <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="acd05cccabee0ffec4485522c899ae2dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfl_1_1_node.html">Node</a>* maxTreeNister </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>pxOrder</em> = <code>std::less&lt;int&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacefl.html#ab9df0ac37a93c4c1b24f18cc6a33aa1d">pxType</a>&#160;</td>
          <td class="paramname"><em>curType</em> = <code>regular</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the max-tree using algorithm from: D. Nister, H. Stewenius: "Linear time
maximally stable extremal regions" (2008). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>The image used to construct the max-tree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="classfl_1_1_inclusion_node.html" title="InclusionNode is a single element of any inclusion component tree. ">InclusionNode</a> *</code> (as `Node *) to the root of the max-tree. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pxOrder</td><td>the comparison operator used to determine the order of the pixels. </td></tr>
    <tr><td class="paramname">curType</td><td>the <code>pyType</code> type of the current pixel (fl::pxType::regular, fl::pxType::dual). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a2893b663163e4232728ad2e5a5cc3cba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int fl::Node::_grayLevel</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The gray level of the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>. </p>
<p>In case of monochannel images. </p>

</div>
</div>
<a class="anchor" id="ac903e3f752e49e80083be6a16a45d103"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; fl::Node::_hgrayLevels</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vectorial gray levels of the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> </p>
<p>In case of multichannel images. One gray level per channel. </p>

</div>
</div>
<a class="anchor" id="a15df3d9a3b3b93da31126ab46bf02340"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double fl::Node::_level</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The level of the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> in the hierarchy. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Can be any scalar value, but for some applications only the integral part may be used. </dd></dl>

</div>
</div>
<a class="anchor" id="aecfb3323d7f59b0ea201d8d0b0c6894a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfl_1_1_node.html">Node</a>* fl::Node::_parent</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The pointer to the parent <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Equals to <code>NULL</code> or <code>this</code> if the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> is the root of the tree (has no parent). </dd></dl>

</div>
</div>
<a class="anchor" id="a12345dced6e8bde9aa60d1d5e4840ff7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;int, int&gt; &gt; fl::Node::_S</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The list of own elements. </p>
<p>The list of the <code><a class="el" href="classfl_1_1_node.html" title="Abstract Node, single element of a component tree. ">Node</a></code> not belonging to any of its children. </p>

</div>
</div>
<a class="anchor" id="ad7b299817f904b877dc9df97ceba9831"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fl::Node::ncountKnown</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicator value for node count. </p>
<p>Can be:</p><ul>
<li><code>true</code> if the number of nodes in a subtree is precalculated</li>
<li><code>false</code> if calculation is needed when calling <code><a class="el" href="classfl_1_1_node.html#a892bfb8b12826b9c6b5b23b7670ecc21" title="The number of Nodes in the subtree of this Node. ">nodeCount()</a></code> </li>
</ul>

</div>
</div>
<a class="anchor" id="a7b6785bf14804ad6b5e3effe116f1c86"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fl::Node::sizeKnown</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicator value of size. </p>
<p>Can be:</p><ul>
<li><code>true</code> if the number of elements is precalculated</li>
<li><code>false</code> if calculation is needed when calling <code><a class="el" href="classfl_1_1_node.html#a7cfbea98e4d84dad5a492e2f731c36d0" title="The number of elements associated to the Node. ">elementCount()</a></code> </li>
</ul>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="node_8h_source.html">node.h</a></li>
<li>node.cpp</li>
<li><a class="el" href="node_8tpp.html">node.tpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacefl.html">fl</a></li><li class="navelem"><a class="el" href="classfl_1_1_node.html">Node</a></li>
    <li class="footer">Generated on Sat Sep 10 2016 19:10:29 for Trees by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.7 </li>
  </ul>
</div>
</body>
</html>
